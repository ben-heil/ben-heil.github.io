---
layout: post
title: Reproducible Programming for Biologists Who Code
subtitle: "Part 3: Nice To Dos"
description: "How to polish your code"
cover-img: "/assets/img/cherry_blossoms.jpg"
citable: true
---

<a id="overview"></a>
# Overview
Welcome to the third and final post in the Reproducible Programming for Biologists Who Code series.

The items in this post are things that are nice to do.
Where [previous posts](https://ben-heil.github.io/2020-06-16-mustdo/) had [suggestions](https://ben-heil.github.io/2020-06-30-shoulddo/)
for making your code more likely to be reproducible, some of the ideas in this post make the work easier to reproduce.

#### Table of Contents:
- [Overview](#overview)
- [Testing Code](#testing)
- - [pytest](#pytest)
- - [testthat](#testthat)
- [Even More Readable Code](#readability)
- - [Code Cleanup](#cleaning)
- - [Linting](#linting)
- - [Python Typing](#mypy)
- [Continuous Integration](#ci)
- [Creating Code Containers](#containers)
- - [Docker](#docker)
- - [Binder](#binder)
- [Creating a Documentation Site](#documentation)
- [Archiving Code](#archive)
- [Linux Package Management](#guix)
- [Acknowledgements](#acknowledgements)

<a id="testing"></a>
## Testing Code
How do you know that your code works?
Is it that it runs without throwing any errors?
Is it that the output is in the correct shape?
Or that the genes that are output at the end seem biologically plausible?

One way to help ensure your code works is to test it.
You probably already test your code in an ad hoc manner by running it as you write it.
By taking a more structured approach to testing your code, you can ensure to both yourself and future users that everything works correctly.
As an added bonus you'll find that writing test cases encourages you to [structure your code into functions](https://ben-heil.github.io/2020-06-30-shoulddo/#code).

There are [a number of types of tests](https://stackoverflow.com/questions/7672511/unit-test-integration-test-regression-test-acceptance-test)
that are used in software development, but the two main types used in science are regression tests and unit tests.
Unit tests are test cases used to ensure each function you write behaves like you'd expect it to.
Likewise, when you find bugs in your code and fix them, you write a regression test to ensure that the bug doesn't come back.

There are a number of libraries that help you organize and write these test cases, but the ones I've selected are [pytest](https://docs.pytest.org/en/stable/contents.html)
for Python and [testthat](https://testthat.r-lib.org/) for R.

<a id="pytest"></a>
### pytest
Pytest is similar to the builtin [unittest](https://docs.python.org/3/library/unittest.html) package, but is simpler to set up and work with.
After installation, you can run `py.test <test_dir>` and pytest will find all the files with `_test` or `test_` in their name and look through the files for test cases.
Test cases in pytest are functions marked by having `test` in their names.
Pytest will then run all the test cases and report which tests passed and which failed.

Some example pytest code is below:
``` python
# test_utils.py

import utils  # A file with functions to be tested

def test_square():
    assert utils.square(0) == 0
    assert utils.square(3) == 9
    assert utils.square(-1) == 1
```

<a id="testthat"></a>
### testthat
In terms of finding test functions, `testthat` works similarly to `pytest`.
It also creates the test/testthat directory for you when you run `usethis::use_testthat()`.
The logic of how the test cases are structured is different than in `pytest` though, so be sure to read [the documentation](https://testthat.r-lib.org/reference/index.html)
if you're coming from a python background.

Code for `testthat` looks like this:

``` R
# test-square.R

library(utils)

test_that("Square function works correctly", {
    expect_equal(square(0), 0)
    expect_equal(square(3), 9)
    expect_equal(square(-1), 1)
})

```

### Further Reading:
- [This article](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4629271/) discusses the impact of bugs in science.
- For a tutorial on pytest, [read this post](https://semaphoreci.com/community/tutorials/testing-python-applications-with-pytest).
- The documentation for testthat is somewhat vague on how testthat should actually be used, but it links to [a textbook chapter](https://r-pkgs.org/tests.html) that is more descriptive.


<a id="readability"></a>
## Even More Readable Code
<a id="cleaning"></a>
### Code Cleanup
<a id="linting"></a>
### Linting
<a id="mypy"></a>
### Python Typing

<a id="ci"></a>
## Continuous Integration

<a id="containers"></a>
## Creating Code Containers
<a id="docker"></a>
### Docker
<a id="binder"></a>
### Binder


<a id="documentation"></a>
## Creating a Documentation Site

<a id="archive"></a>
## Archiving Code

<a id="guix"></a>
## Linux Package Management

<a id="acknowledgements"></a>
## Acknowledgements
Thanks to [Wayne](https://twitter.com/Fomightez) for introducing me to Binder, and to
[Sabrina Granger](https://twitter.com/sabr_granger) for telling me about Guix and Software Heritage.
