---
layout: post
title: Reproducible Programming for Biologists Who Code
subtitle: "Part 3: Nice To Dos"
description: "How to polish your code"
cover-img: "/assets/img/cherry_blossoms.jpg"
citable: true
---

<a id="overview"></a>
# Overview
Welcome to the third and final post in the Reproducible Programming for Biologists Who Code series.

The items in this post are things that are nice to do.
Where [previous posts](https://ben-heil.github.io/2020-06-16-mustdo/) had [suggestions](https://ben-heil.github.io/2020-06-30-shoulddo/)
for making your code more likely to be reproducible, some of the ideas in this post make the work easier to reproduce.

#### Table of Contents:
- [Overview](#overview)
- [Testing Code](#testing)
- - [pytest](#pytest)
- - [testthat](#testthat)
- [Even More Readable Code](#readability)
- - [Code Cleanup](#cleaning)
- - [Linting](#linting)
- - [Python Typing](#mypy)
- [Continuous Integration](#ci)
- [Creating Code Containers](#containers)
- - [Docker](#docker)
- - [Binder](#binder)
- [Creating a Documentation Site](#documentation)
- [Archiving Code](#archive)
- [Linux Package Management](#guix)
- [Acknowledgements](#acknowledgements)

<a id="testing"></a>
## Testing Code
How do you know that your code works?
Is it that it runs without throwing any errors?
Is it that the output is in the correct shape?
Or that the genes that are output at the end seem biologically plausible?

One way to help ensure your code works is to test it.
You probably already test your code in an ad hoc manner by running it as you write it.
By taking a more structured approach to testing your code, you can ensure to both yourself and future users that everything works correctly.
As an added bonus you'll find that writing test cases encourages you to [structure your code into functions](https://ben-heil.github.io/2020-06-30-shoulddo/#code).

There are [a number of types of tests](https://stackoverflow.com/questions/7672511/unit-test-integration-test-regression-test-acceptance-test)
that are used in software development, but the two main types used in science are regression tests and unit tests.
Unit tests are test cases used to ensure each function you write behaves like you'd expect it to.
Likewise, when you find bugs in your code and fix them, you write a regression test to ensure that the bug doesn't come back.

There are a number of libraries that help you organize and write these test cases, but the ones I've selected are [pytest](https://docs.pytest.org/en/stable/contents.html)
for Python and [testthat](https://testthat.r-lib.org/) for R.

<a id="pytest"></a>
### pytest
Pytest is similar to the builtin [unittest](https://docs.python.org/3/library/unittest.html) package, but is simpler to set up and work with.
After installation, you can run `py.test <test_dir>` and pytest will find all the files with `_test` or `test_` in their name and look through the files for test cases.
Test cases in pytest are functions marked by having `test` in their names.
Pytest will then run all the test cases and report which tests passed and which failed.

Some example pytest code is below:
``` python
# test_utils.py

import utils  # A file with functions to be tested

def test_square():
    assert utils.square(0) == 0
    assert utils.square(3) == 9
    assert utils.square(-1) == 1
```

<a id="testthat"></a>
### testthat
In terms of finding test functions, testthat works similarly to pytest.
It also creates the test/testthat directory for you when you run `usethis::use_testthat()`.
The logic of how the test cases are structured is different than in pytest though, so be sure to read [the documentation](https://testthat.r-lib.org/reference/index.html)
if you're coming from a python background.

Code for testthat looks like this:

``` R
# test-square.R

library(utils)

test_that("Square function works correctly", {
    expect_equal(square(0), 0)
    expect_equal(square(3), 9)
    expect_equal(square(-1), 1)
})

```

### Further Reading:
- [This article](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4629271/) discusses the impact of bugs in science.
- For a tutorial on pytest, [read this post](https://semaphoreci.com/community/tutorials/testing-python-applications-with-pytest).
- The documentation for testthat is somewhat vague on how testthat should actually be used, but it links to [a textbook chapter](https://r-pkgs.org/tests.html) that is more descriptive.


<a id="readability"></a>
## Even More Readable Code
<a id="cleaning"></a>
### Code Cleanup
Before [publishing your code](https://ben-heil.github.io/2020-06-16-mustdo/#publishing) it's good to give it a once-over to make sure everything is in order.
I personally end up with a lot of commented out code and debugging print statements throughout the course of writing a program.
While these were helpful to me once, they aren't helpful to others, and the code looks much nicer when they're removed.
Likewise unused module imports and functions can and should be removed.

<a id="linting"></a>
### Linting
I wish I had a program that would correct me when I made fashion mistakes.
A computer dispassionately telling me that I shouldn't wear blue stripes with blue plaid would save me a lot of brainpower when putting together outfits.
To my knowledge a program for correcting personal style doesn't exist, but programs for fixing programming style do.

These programs are called linters, and they keep you from having to keep track of [tomes worth](https://www.python.org/dev/peps/pep-0008/) of style information.
Using a linter both makes your code easier for you and others to read, and saves the energy of having to memorize the style standards of the language you're using.

There are a number of linters in python, but I would recommend using either [pylint](http://pylint.pycqa.org/en/latest/index.html) or [Black](https://pypi.org/project/black/).
Pylint is a straightforward linter that matches the python PEP8 style standard.
Black is different from other linters in that it modifies the code to match its idea of style.
The choice between the two is rather you would rather have more flexibility with pylint or never have to worry about anything style related with Black.

In R your choices are between the built-in RStudio static analysis tools and [lintr](https://github.com/jimhester/lintr).
The choice between them is whether you want the added options present in lintr or the ease of having the tool built into RStudio.

### Further Reading:
- [How to integrate pylint into your editor of choice](http://pylint.pycqa.org/en/latest/user_guide/ide-integration.html)
- [How to integrate black into your editor of choice](https://black.readthedocs.io/en/stable/editor_integration.html)
- [How to integrate lintr into RStudio](https://community.rstudio.com/t/lintr-integration-with-rstudio/1807/7)

<a id="mypy"></a>
### Python Typing


<a id="ci"></a>
## Continuous Integration

<a id="containers"></a>
## Creating Code Containers
<a id="docker"></a>
### Docker
<a id="binder"></a>
### Binder


<a id="documentation"></a>
## Creating a Documentation Site

<a id="archive"></a>
## Archiving Code

<a id="guix"></a>
## Linux Package Management

<a id="acknowledgements"></a>
## Acknowledgements
Thanks to [Wayne](https://twitter.com/Fomightez) for introducing me to Binder, and to
[Sabrina Granger](https://twitter.com/GrangerSabrina1) for telling me about Guix and Software Heritage.
