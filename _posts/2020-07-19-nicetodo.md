---
layout: post
title: Reproducible Programming for Biologists Who Code
subtitle: "Part 3: Nice To Dos"
description: "How to polish your code"
cover-img: "/assets/img/cherry_blossoms.jpg"
citable: true
---

<a id="overview"></a>
# Overview
Welcome to the third and final post in the Reproducible Programming for Biologists Who Code series.

The items in this post are things that are nice to do.
Where [previous posts](https://ben-heil.github.io/2020-06-16-mustdo/) had [suggestions](https://ben-heil.github.io/2020-06-30-shoulddo/)
for making your code more likely to be reproducible, some of the ideas in this post make the work easier to reproduce.

#### Table of Contents:
- [Overview](#overview)
- [Testing Code](#testing)
- - [pytest](#pytest)
- - [testthat](#testthat)
- [Even More Readable Code](#readability)
- - [Code Cleanup](#cleaning)
- - [Linting](#linting)
- - [Python Typing](#mypy)
- [Continuous Integration](#ci)
- [Creating Code Containers](#containers)
- - [Docker](#docker)
- - [Binder](#binder)
- [Creating a Documentation Site](#documentation)
- [Archiving Code](#archive)
- [Linux Package Management](#guix)
- [Acknowledgements](#acknowledgements)

<a id="testing"></a>
## Testing Code
How do you know that your code works?
Is it that it runs without throwing any errors?
Is it that the output is in the correct shape?
Or that the genes that are output at the end seem biologically plausible?

One way to help ensure your code works is to test it.
You probably already test your code in an ad hoc manner by running it as you write it.
By taking a more structured approach to testing your code, you can ensure to both yourself and future users that everything works correctly.
As an added bonus you'll find that writing test cases encourages you to [structure your code into functions](https://ben-heil.github.io/2020-06-30-shoulddo/#code).

There are [a number of types of tests](https://stackoverflow.com/questions/7672511/unit-test-integration-test-regression-test-acceptance-test)
that are used in software development, but the two main types used in science are regression tests and unit tests.
Unit tests are test cases used to ensure each function you write behaves like you'd expect it to.
Likewise, when you find bugs in your code and fix them, you write a regression test to ensure that the bug doesn't come back.

There are a number of libraries that help you organize and write these test cases, but the ones I've selected are [pytest](https://docs.pytest.org/en/stable/contents.html)
for Python and [testthat](https://testthat.r-lib.org/) for R.

<a id="pytest"></a>
### pytest
Pytest is similar to the builtin [unittest](https://docs.python.org/3/library/unittest.html) package, but is simpler to set up and work with.
After installation, you can run `py.test <test_dir>` and pytest will find all the files with `_test` or `test_` in their name and look through the files for test cases.
Test cases in pytest are functions marked by having `test` in their names.
Pytest will then run all the test cases and report which tests passed and which failed.

Some example pytest code is below:
``` python
# test_utils.py

import utils  # A file with functions to be tested

def test_square():
    assert utils.square(0) == 0
    assert utils.square(3) == 9
    assert utils.square(-1) == 1
```

<a id="testthat"></a>
### testthat
In terms of finding test functions, testthat works similarly to pytest.
It also creates the test/testthat directory for you when you run `usethis::use_testthat()`.
The logic of how the test cases are structured is different than in pytest though, so be sure to read [the documentation](https://testthat.r-lib.org/reference/index.html)
if you're coming from a python background.

Code for testthat looks like this:

``` R
# test-square.R

library(utils)

test_that("Square function works correctly", {
    expect_equal(square(0), 0)
    expect_equal(square(3), 9)
    expect_equal(square(-1), 1)
})

```

#### Further Reading:
- [This article](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4629271/) discusses the impact of bugs in science.
- For a tutorial on pytest, [read this post](https://semaphoreci.com/community/tutorials/testing-python-applications-with-pytest).
- The documentation for testthat is somewhat vague on how testthat should actually be used, but it links to [a textbook chapter](https://r-pkgs.org/tests.html) that is more descriptive.


<a id="readability"></a>
## Even More Readable Code
<a id="cleaning"></a>
### Code Cleanup
Before [publishing your code](https://ben-heil.github.io/2020-06-16-mustdo/#publishing) it's good to give it a once-over to make sure everything is in order.
I personally end up with a lot of commented out code and debugging print statements throughout the course of writing a program.
While these were helpful to me once, they aren't helpful to others, and the code looks much nicer when they're removed.
Likewise unused module imports and functions can and should be removed.

<a id="linting"></a>
### Linting
I wish I had a program that would correct me when I made fashion mistakes.
A computer dispassionately telling me that I shouldn't wear blue stripes with blue plaid would save me a lot of brainpower when putting together outfits.
To my knowledge a program for correcting personal style doesn't exist, but programs for fixing programming style do.

These programs are called linters, and they keep you from having to keep track of [tomes worth](https://www.python.org/dev/peps/pep-0008/) of style information.
Using a linter both makes your code easier for you and others to read, and saves the energy of having to memorize the style standards of the language you're using.

There are a number of linters in python, but I would recommend using either [pylint](http://pylint.pycqa.org/en/latest/index.html) or [Black](https://pypi.org/project/black/).
Pylint is a straightforward linter that matches the python PEP8 style standard.
Black is different from other linters in that it modifies the code to match its idea of style.
The choice between the two is rather you would rather have more flexibility with pylint or never have to worry about anything style related with Black.

In R your choices are between the built-in RStudio static analysis tools and [lintr](https://github.com/jimhester/lintr).
The choice between them is whether you want the added options present in lintr or the ease of having the tool built into RStudio.

#### Further Reading:
- [How to integrate pylint into your editor of choice](http://pylint.pycqa.org/en/latest/user_guide/ide-integration.html)
- [How to integrate black into your editor of choice](https://black.readthedocs.io/en/stable/editor_integration.html)
- [How to integrate lintr into RStudio](https://community.rstudio.com/t/lintr-integration-with-rstudio/1807/7)

<a id="mypy"></a>
### Python Typing
There is a library called [mypy](https://mypy.readthedocs.io/en/stable/) that allows you to predict bugs by
marking the [data types](https://docs.python.org/3/library/datatypes.html) in your python code.
"But wait," I'm sure you're asking, "if I wanted to write [statically typed](https://docs.oracle.com/cd/E57471_01/bigData.100/extensions_bdd/src/cext_transform_typing.html)
code I'd use Rust instead of Python."
It's a fair point.
But what if I told you that the code is only a little bit statically typed?

Having to specify the type of every variable in your code is kind of a pain, so I don't do it.
If we're [already keeping track of the types of our function arguments](https://ben-heil.github.io/2020-06-30-shoulddo/#commenting) though, we might as well get some error checking for free.
By running mypy like any other linter, you can find bugs in code without having to run the code.

[Some work](https://community.rstudio.com/t/any-plans-for-mypy-equivalent-for-r/40282/3) has been done to make a mypy equivalent in R, but they haven't reached the same standard as mypy so far.

#### Further Reading:
- [How to integrate mypy into your editor](https://github.com/python/mypy#ide-linter-integrations-and-pre-commit)
- [A guide to python type checking](https://realpython.com/python-type-checking/). The first section, "Hello Types", contains the extent of typing that I do,
though there is much more depth if you're interested.

<a id="ci"></a>
## Continuous Integration
At this point you're probably thinking "That sure is a lot of programs to keep track of running when I write code."
Luckily, there is a type of software called continuous integration service that is designed to run your tests and linters automatically.
Even better, it syncs with [your version control platform](https://ben-heil.github.io/2020-06-16-mustdo/#version-control).

The idea behind continuous integration (CI) is that there is a set of tasks that you want to run each time you add code to your repository.
CI services will do these tasks [on a different computer](https://ben-heil.github.io/2020-06-30-shoulddo/#rerun) for you
and even give you [a shiny badge](https://docs.travis-ci.com/user/status-images/) to put in your [README](https://ben-heil.github.io/2020-06-30-shoulddo/#readme) so everyone knows your code works.

You have tons of options when it comes to CI services, including [Travis CI](https://travis-ci.org/), [CircleCI](https://circleci.com/),
[TeamCity](https://www.jetbrains.com/teamcity/), and [Github Actions](https://github.com/features/actions).
They all do more or less the same thing, so I'd recommend picking whichever seems the easiest to set up for you.
That being said, Github Actions still feels like it's a beta release.
If you can find prebuilt actions that do what you want and you're already using Github as your version control platform, then go ahead.
Just be aware that it can be [a pain to work with conda](https://github.com/actions/starter-workflows/issues/44) in Actions.

Mostly CI is used for basic functions such as [testing code](#testing), [linting](#linting) it, and [publishing it to pypi](https://docs.travis-ci.com/user/deployment/pypi/).
It can also be used more creatively to do things like [continuously rebuild a manuscript](https://github.com/greenelab/deep-review) as you write it.
(Full disclosure, I'm in Greenelab, as are some of the authors on the paper.)

#### Further Reading:
- [A guide to using Travis CI for R](https://juliasilge.com/blog/beginners-guide-to-travis/)
- [A guide to using Travis CI for python](https://towardsdatascience.com/extensive-python-testing-on-travis-ci-4c24db9bf961)

<a id="containers"></a>
## Creating Code Containers
<a id="docker"></a>
### Docker
<a id="binder"></a>
### Binder


<a id="documentation"></a>
## Creating a Documentation Site

<a id="archive"></a>
## Archiving Code

<a id="guix"></a>
## Linux Package Management

<a id="acknowledgements"></a>
## Acknowledgements
Thanks to [Wayne](https://twitter.com/Fomightez) for introducing me to Binder, and to
[Sabrina Granger](https://twitter.com/GrangerSabrina1) for telling me about Guix and Software Heritage.
